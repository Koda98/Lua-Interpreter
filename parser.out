Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> chunk
Rule 1     chunk -> block
Rule 2     block -> stat_list
Rule 3     stat_list -> stat stat_list
Rule 4     stat_list -> empty
Rule 5     stat -> ;
Rule 6     stat -> DO block END
Rule 7     stat -> varlist = explist
Rule 8     stat -> RETURN
Rule 9     stat -> RETURN explist
Rule 10    stat -> RETURN ;
Rule 11    stat -> RETURN explist ;
Rule 12    varlist -> var
Rule 13    varlist -> var , varlist
Rule 14    var -> IDENTIFIER
Rule 15    explist -> exp
Rule 16    explist -> exp , explist
Rule 17    exp -> exp PLUS exp
Rule 18    exp -> exp MINUS exp
Rule 19    exp -> exp TIMES exp
Rule 20    exp -> exp DIVIDE exp
Rule 21    exp -> exp INTEGER_DIVIDE exp
Rule 22    exp -> ( exp )
Rule 23    exp -> var
Rule 24    exp -> NUMBER
Rule 25    exp -> MINUS exp
Rule 26    empty -> <empty>

Terminals, with rules where they appear

(                    : 22
)                    : 22
,                    : 13 16
;                    : 5 10 11
=                    : 7
DIVIDE               : 20
DO                   : 6
END                  : 6
IDENTIFIER           : 14
INTEGER_DIVIDE       : 21
MINUS                : 18 25
NUMBER               : 24
PLUS                 : 17
RETURN               : 8 9 10 11
TIMES                : 19
error                : 

Nonterminals, with rules where they appear

block                : 1 6
chunk                : 0
empty                : 4
exp                  : 15 16 17 17 18 18 19 19 20 20 21 21 22 25
explist              : 7 9 11 16
stat                 : 3
stat_list            : 2 3
var                  : 12 13 23
varlist              : 7 13

Parsing method: LALR

state 0

    (0) S' -> . chunk
    (1) chunk -> . block
    (2) block -> . stat_list
    (3) stat_list -> . stat stat_list
    (4) stat_list -> . empty
    (5) stat -> . ;
    (6) stat -> . DO block END
    (7) stat -> . varlist = explist
    (8) stat -> . RETURN
    (9) stat -> . RETURN explist
    (10) stat -> . RETURN ;
    (11) stat -> . RETURN explist ;
    (26) empty -> .
    (12) varlist -> . var
    (13) varlist -> . var , varlist
    (14) var -> . IDENTIFIER

    ;               shift and go to state 6
    DO              shift and go to state 7
    RETURN          shift and go to state 9
    $end            reduce using rule 26 (empty -> .)
    IDENTIFIER      shift and go to state 11

    chunk                          shift and go to state 1
    block                          shift and go to state 2
    stat_list                      shift and go to state 3
    stat                           shift and go to state 4
    empty                          shift and go to state 5
    varlist                        shift and go to state 8
    var                            shift and go to state 10

state 1

    (0) S' -> chunk .



state 2

    (1) chunk -> block .

    $end            reduce using rule 1 (chunk -> block .)


state 3

    (2) block -> stat_list .

    $end            reduce using rule 2 (block -> stat_list .)
    END             reduce using rule 2 (block -> stat_list .)


state 4

    (3) stat_list -> stat . stat_list
    (3) stat_list -> . stat stat_list
    (4) stat_list -> . empty
    (5) stat -> . ;
    (6) stat -> . DO block END
    (7) stat -> . varlist = explist
    (8) stat -> . RETURN
    (9) stat -> . RETURN explist
    (10) stat -> . RETURN ;
    (11) stat -> . RETURN explist ;
    (26) empty -> .
    (12) varlist -> . var
    (13) varlist -> . var , varlist
    (14) var -> . IDENTIFIER

    ;               shift and go to state 6
    DO              shift and go to state 7
    RETURN          shift and go to state 9
    $end            reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)
    IDENTIFIER      shift and go to state 11

    stat                           shift and go to state 4
    stat_list                      shift and go to state 12
    empty                          shift and go to state 5
    varlist                        shift and go to state 8
    var                            shift and go to state 10

state 5

    (4) stat_list -> empty .

    $end            reduce using rule 4 (stat_list -> empty .)
    END             reduce using rule 4 (stat_list -> empty .)


state 6

    (5) stat -> ; .

    ;               reduce using rule 5 (stat -> ; .)
    DO              reduce using rule 5 (stat -> ; .)
    RETURN          reduce using rule 5 (stat -> ; .)
    IDENTIFIER      reduce using rule 5 (stat -> ; .)
    $end            reduce using rule 5 (stat -> ; .)
    END             reduce using rule 5 (stat -> ; .)


state 7

    (6) stat -> DO . block END
    (2) block -> . stat_list
    (3) stat_list -> . stat stat_list
    (4) stat_list -> . empty
    (5) stat -> . ;
    (6) stat -> . DO block END
    (7) stat -> . varlist = explist
    (8) stat -> . RETURN
    (9) stat -> . RETURN explist
    (10) stat -> . RETURN ;
    (11) stat -> . RETURN explist ;
    (26) empty -> .
    (12) varlist -> . var
    (13) varlist -> . var , varlist
    (14) var -> . IDENTIFIER

    ;               shift and go to state 6
    DO              shift and go to state 7
    RETURN          shift and go to state 9
    END             reduce using rule 26 (empty -> .)
    IDENTIFIER      shift and go to state 11

    block                          shift and go to state 13
    stat_list                      shift and go to state 3
    stat                           shift and go to state 4
    empty                          shift and go to state 5
    varlist                        shift and go to state 8
    var                            shift and go to state 10

state 8

    (7) stat -> varlist . = explist

    =               shift and go to state 14


state 9

    (8) stat -> RETURN .
    (9) stat -> RETURN . explist
    (10) stat -> RETURN . ;
    (11) stat -> RETURN . explist ;
    (15) explist -> . exp
    (16) explist -> . exp , explist
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    DO              reduce using rule 8 (stat -> RETURN .)
    RETURN          reduce using rule 8 (stat -> RETURN .)
    $end            reduce using rule 8 (stat -> RETURN .)
    END             reduce using rule 8 (stat -> RETURN .)
    ;               shift and go to state 16
    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

  ! ;               [ reduce using rule 8 (stat -> RETURN .) ]
  ! IDENTIFIER      [ reduce using rule 8 (stat -> RETURN .) ]

    explist                        shift and go to state 15
    exp                            shift and go to state 17
    var                            shift and go to state 20

state 10

    (12) varlist -> var .
    (13) varlist -> var . , varlist

    =               reduce using rule 12 (varlist -> var .)
    ,               shift and go to state 22


state 11

    (14) var -> IDENTIFIER .

    ,               reduce using rule 14 (var -> IDENTIFIER .)
    =               reduce using rule 14 (var -> IDENTIFIER .)
    PLUS            reduce using rule 14 (var -> IDENTIFIER .)
    MINUS           reduce using rule 14 (var -> IDENTIFIER .)
    TIMES           reduce using rule 14 (var -> IDENTIFIER .)
    DIVIDE          reduce using rule 14 (var -> IDENTIFIER .)
    INTEGER_DIVIDE  reduce using rule 14 (var -> IDENTIFIER .)
    ;               reduce using rule 14 (var -> IDENTIFIER .)
    DO              reduce using rule 14 (var -> IDENTIFIER .)
    RETURN          reduce using rule 14 (var -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 14 (var -> IDENTIFIER .)
    $end            reduce using rule 14 (var -> IDENTIFIER .)
    END             reduce using rule 14 (var -> IDENTIFIER .)
    )               reduce using rule 14 (var -> IDENTIFIER .)


state 12

    (3) stat_list -> stat stat_list .

    $end            reduce using rule 3 (stat_list -> stat stat_list .)
    END             reduce using rule 3 (stat_list -> stat stat_list .)


state 13

    (6) stat -> DO block . END

    END             shift and go to state 23


state 14

    (7) stat -> varlist = . explist
    (15) explist -> . exp
    (16) explist -> . exp , explist
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    explist                        shift and go to state 24
    exp                            shift and go to state 17
    var                            shift and go to state 20

state 15

    (9) stat -> RETURN explist .
    (11) stat -> RETURN explist . ;

  ! shift/reduce conflict for ; resolved as shift
    DO              reduce using rule 9 (stat -> RETURN explist .)
    RETURN          reduce using rule 9 (stat -> RETURN explist .)
    IDENTIFIER      reduce using rule 9 (stat -> RETURN explist .)
    $end            reduce using rule 9 (stat -> RETURN explist .)
    END             reduce using rule 9 (stat -> RETURN explist .)
    ;               shift and go to state 25

  ! ;               [ reduce using rule 9 (stat -> RETURN explist .) ]


state 16

    (10) stat -> RETURN ; .

    ;               reduce using rule 10 (stat -> RETURN ; .)
    DO              reduce using rule 10 (stat -> RETURN ; .)
    RETURN          reduce using rule 10 (stat -> RETURN ; .)
    IDENTIFIER      reduce using rule 10 (stat -> RETURN ; .)
    $end            reduce using rule 10 (stat -> RETURN ; .)
    END             reduce using rule 10 (stat -> RETURN ; .)


state 17

    (15) explist -> exp .
    (16) explist -> exp . , explist
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ;               reduce using rule 15 (explist -> exp .)
    DO              reduce using rule 15 (explist -> exp .)
    RETURN          reduce using rule 15 (explist -> exp .)
    IDENTIFIER      reduce using rule 15 (explist -> exp .)
    $end            reduce using rule 15 (explist -> exp .)
    END             reduce using rule 15 (explist -> exp .)
    ,               shift and go to state 26
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    INTEGER_DIVIDE  shift and go to state 31


state 18

    (25) exp -> MINUS . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 32
    var                            shift and go to state 20

state 19

    (22) exp -> ( . exp )
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 33
    var                            shift and go to state 20

state 20

    (23) exp -> var .

    ,               reduce using rule 23 (exp -> var .)
    PLUS            reduce using rule 23 (exp -> var .)
    MINUS           reduce using rule 23 (exp -> var .)
    TIMES           reduce using rule 23 (exp -> var .)
    DIVIDE          reduce using rule 23 (exp -> var .)
    INTEGER_DIVIDE  reduce using rule 23 (exp -> var .)
    ;               reduce using rule 23 (exp -> var .)
    DO              reduce using rule 23 (exp -> var .)
    RETURN          reduce using rule 23 (exp -> var .)
    IDENTIFIER      reduce using rule 23 (exp -> var .)
    $end            reduce using rule 23 (exp -> var .)
    END             reduce using rule 23 (exp -> var .)
    )               reduce using rule 23 (exp -> var .)


state 21

    (24) exp -> NUMBER .

    ,               reduce using rule 24 (exp -> NUMBER .)
    PLUS            reduce using rule 24 (exp -> NUMBER .)
    MINUS           reduce using rule 24 (exp -> NUMBER .)
    TIMES           reduce using rule 24 (exp -> NUMBER .)
    DIVIDE          reduce using rule 24 (exp -> NUMBER .)
    INTEGER_DIVIDE  reduce using rule 24 (exp -> NUMBER .)
    ;               reduce using rule 24 (exp -> NUMBER .)
    DO              reduce using rule 24 (exp -> NUMBER .)
    RETURN          reduce using rule 24 (exp -> NUMBER .)
    IDENTIFIER      reduce using rule 24 (exp -> NUMBER .)
    $end            reduce using rule 24 (exp -> NUMBER .)
    END             reduce using rule 24 (exp -> NUMBER .)
    )               reduce using rule 24 (exp -> NUMBER .)


state 22

    (13) varlist -> var , . varlist
    (12) varlist -> . var
    (13) varlist -> . var , varlist
    (14) var -> . IDENTIFIER

    IDENTIFIER      shift and go to state 11

    var                            shift and go to state 10
    varlist                        shift and go to state 34

state 23

    (6) stat -> DO block END .

    ;               reduce using rule 6 (stat -> DO block END .)
    DO              reduce using rule 6 (stat -> DO block END .)
    RETURN          reduce using rule 6 (stat -> DO block END .)
    IDENTIFIER      reduce using rule 6 (stat -> DO block END .)
    $end            reduce using rule 6 (stat -> DO block END .)
    END             reduce using rule 6 (stat -> DO block END .)


state 24

    (7) stat -> varlist = explist .

    ;               reduce using rule 7 (stat -> varlist = explist .)
    DO              reduce using rule 7 (stat -> varlist = explist .)
    RETURN          reduce using rule 7 (stat -> varlist = explist .)
    IDENTIFIER      reduce using rule 7 (stat -> varlist = explist .)
    $end            reduce using rule 7 (stat -> varlist = explist .)
    END             reduce using rule 7 (stat -> varlist = explist .)


state 25

    (11) stat -> RETURN explist ; .

    ;               reduce using rule 11 (stat -> RETURN explist ; .)
    DO              reduce using rule 11 (stat -> RETURN explist ; .)
    RETURN          reduce using rule 11 (stat -> RETURN explist ; .)
    IDENTIFIER      reduce using rule 11 (stat -> RETURN explist ; .)
    $end            reduce using rule 11 (stat -> RETURN explist ; .)
    END             reduce using rule 11 (stat -> RETURN explist ; .)


state 26

    (16) explist -> exp , . explist
    (15) explist -> . exp
    (16) explist -> . exp , explist
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 17
    explist                        shift and go to state 35
    var                            shift and go to state 20

state 27

    (17) exp -> exp PLUS . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 36
    var                            shift and go to state 20

state 28

    (18) exp -> exp MINUS . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 37
    var                            shift and go to state 20

state 29

    (19) exp -> exp TIMES . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 38
    var                            shift and go to state 20

state 30

    (20) exp -> exp DIVIDE . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 39
    var                            shift and go to state 20

state 31

    (21) exp -> exp INTEGER_DIVIDE . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp INTEGER_DIVIDE exp
    (22) exp -> . ( exp )
    (23) exp -> . var
    (24) exp -> . NUMBER
    (25) exp -> . MINUS exp
    (14) var -> . IDENTIFIER

    (               shift and go to state 19
    NUMBER          shift and go to state 21
    MINUS           shift and go to state 18
    IDENTIFIER      shift and go to state 11

    exp                            shift and go to state 40
    var                            shift and go to state 20

state 32

    (25) exp -> MINUS exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ,               reduce using rule 25 (exp -> MINUS exp .)
    PLUS            reduce using rule 25 (exp -> MINUS exp .)
    MINUS           reduce using rule 25 (exp -> MINUS exp .)
    TIMES           reduce using rule 25 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 25 (exp -> MINUS exp .)
    INTEGER_DIVIDE  reduce using rule 25 (exp -> MINUS exp .)
    ;               reduce using rule 25 (exp -> MINUS exp .)
    DO              reduce using rule 25 (exp -> MINUS exp .)
    RETURN          reduce using rule 25 (exp -> MINUS exp .)
    IDENTIFIER      reduce using rule 25 (exp -> MINUS exp .)
    $end            reduce using rule 25 (exp -> MINUS exp .)
    END             reduce using rule 25 (exp -> MINUS exp .)
    )               reduce using rule 25 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! INTEGER_DIVIDE  [ shift and go to state 31 ]


state 33

    (22) exp -> ( exp . )
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    )               shift and go to state 41
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    INTEGER_DIVIDE  shift and go to state 31


state 34

    (13) varlist -> var , varlist .

    =               reduce using rule 13 (varlist -> var , varlist .)


state 35

    (16) explist -> exp , explist .

    ;               reduce using rule 16 (explist -> exp , explist .)
    DO              reduce using rule 16 (explist -> exp , explist .)
    RETURN          reduce using rule 16 (explist -> exp , explist .)
    IDENTIFIER      reduce using rule 16 (explist -> exp , explist .)
    $end            reduce using rule 16 (explist -> exp , explist .)
    END             reduce using rule 16 (explist -> exp , explist .)


state 36

    (17) exp -> exp PLUS exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ,               reduce using rule 17 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 17 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 17 (exp -> exp PLUS exp .)
    ;               reduce using rule 17 (exp -> exp PLUS exp .)
    DO              reduce using rule 17 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 17 (exp -> exp PLUS exp .)
    IDENTIFIER      reduce using rule 17 (exp -> exp PLUS exp .)
    $end            reduce using rule 17 (exp -> exp PLUS exp .)
    END             reduce using rule 17 (exp -> exp PLUS exp .)
    )               reduce using rule 17 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    INTEGER_DIVIDE  shift and go to state 31

  ! TIMES           [ reduce using rule 17 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 17 (exp -> exp PLUS exp .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 17 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]


state 37

    (18) exp -> exp MINUS exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ,               reduce using rule 18 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 18 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 18 (exp -> exp MINUS exp .)
    ;               reduce using rule 18 (exp -> exp MINUS exp .)
    DO              reduce using rule 18 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 18 (exp -> exp MINUS exp .)
    IDENTIFIER      reduce using rule 18 (exp -> exp MINUS exp .)
    $end            reduce using rule 18 (exp -> exp MINUS exp .)
    END             reduce using rule 18 (exp -> exp MINUS exp .)
    )               reduce using rule 18 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    INTEGER_DIVIDE  shift and go to state 31

  ! TIMES           [ reduce using rule 18 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 18 (exp -> exp MINUS exp .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 18 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]


state 38

    (19) exp -> exp TIMES exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ,               reduce using rule 19 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 19 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 19 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 19 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 19 (exp -> exp TIMES exp .)
    INTEGER_DIVIDE  reduce using rule 19 (exp -> exp TIMES exp .)
    ;               reduce using rule 19 (exp -> exp TIMES exp .)
    DO              reduce using rule 19 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 19 (exp -> exp TIMES exp .)
    IDENTIFIER      reduce using rule 19 (exp -> exp TIMES exp .)
    $end            reduce using rule 19 (exp -> exp TIMES exp .)
    END             reduce using rule 19 (exp -> exp TIMES exp .)
    )               reduce using rule 19 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! INTEGER_DIVIDE  [ shift and go to state 31 ]


state 39

    (20) exp -> exp DIVIDE exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ,               reduce using rule 20 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 20 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 20 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 20 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 20 (exp -> exp DIVIDE exp .)
    INTEGER_DIVIDE  reduce using rule 20 (exp -> exp DIVIDE exp .)
    ;               reduce using rule 20 (exp -> exp DIVIDE exp .)
    DO              reduce using rule 20 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 20 (exp -> exp DIVIDE exp .)
    IDENTIFIER      reduce using rule 20 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 20 (exp -> exp DIVIDE exp .)
    END             reduce using rule 20 (exp -> exp DIVIDE exp .)
    )               reduce using rule 20 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! INTEGER_DIVIDE  [ shift and go to state 31 ]


state 40

    (21) exp -> exp INTEGER_DIVIDE exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . INTEGER_DIVIDE exp

    ,               reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    PLUS            reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    MINUS           reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    TIMES           reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    DIVIDE          reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    INTEGER_DIVIDE  reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    ;               reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    DO              reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    RETURN          reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    IDENTIFIER      reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    $end            reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    END             reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)
    )               reduce using rule 21 (exp -> exp INTEGER_DIVIDE exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! INTEGER_DIVIDE  [ shift and go to state 31 ]


state 41

    (22) exp -> ( exp ) .

    ,               reduce using rule 22 (exp -> ( exp ) .)
    PLUS            reduce using rule 22 (exp -> ( exp ) .)
    MINUS           reduce using rule 22 (exp -> ( exp ) .)
    TIMES           reduce using rule 22 (exp -> ( exp ) .)
    DIVIDE          reduce using rule 22 (exp -> ( exp ) .)
    INTEGER_DIVIDE  reduce using rule 22 (exp -> ( exp ) .)
    ;               reduce using rule 22 (exp -> ( exp ) .)
    DO              reduce using rule 22 (exp -> ( exp ) .)
    RETURN          reduce using rule 22 (exp -> ( exp ) .)
    IDENTIFIER      reduce using rule 22 (exp -> ( exp ) .)
    $end            reduce using rule 22 (exp -> ( exp ) .)
    END             reduce using rule 22 (exp -> ( exp ) .)
    )               reduce using rule 22 (exp -> ( exp ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ; in state 9 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 9 resolved as shift
WARNING: shift/reduce conflict for ; in state 15 resolved as shift
