Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> chunk
Rule 1     chunk -> block
Rule 2     block -> stat_list
Rule 3     stat_list -> stat stat_list
Rule 4     stat_list -> empty
Rule 5     stat -> ;
Rule 6     stat -> varlist = explist
Rule 7     stat -> RETURN
Rule 8     stat -> RETURN exp
Rule 9     stat -> RETURN ;
Rule 10    stat -> RETURN exp ;
Rule 11    varlist -> var
Rule 12    varlist -> var , varlist
Rule 13    var -> IDENTIFIER
Rule 14    explist -> exp
Rule 15    explist -> exp , explist
Rule 16    exp -> exp PLUS exp
Rule 17    exp -> exp MINUS exp
Rule 18    exp -> exp TIMES exp
Rule 19    exp -> exp DIVIDE exp
Rule 20    exp -> ( exp )
Rule 21    exp -> var
Rule 22    exp -> NUMBER
Rule 23    exp -> MINUS exp
Rule 24    empty -> <empty>

Terminals, with rules where they appear

(                    : 20
)                    : 20
,                    : 12 15
;                    : 5 9 10
=                    : 6
DIVIDE               : 19
IDENTIFIER           : 13
MINUS                : 17 23
NUMBER               : 22
PLUS                 : 16
RETURN               : 7 8 9 10
TIMES                : 18
error                : 

Nonterminals, with rules where they appear

block                : 1
chunk                : 0
empty                : 4
exp                  : 8 10 14 15 16 16 17 17 18 18 19 19 20 23
explist              : 6 15
stat                 : 3
stat_list            : 2 3
var                  : 11 12 21
varlist              : 6 12

Parsing method: LALR

state 0

    (0) S' -> . chunk
    (1) chunk -> . block
    (2) block -> . stat_list
    (3) stat_list -> . stat stat_list
    (4) stat_list -> . empty
    (5) stat -> . ;
    (6) stat -> . varlist = explist
    (7) stat -> . RETURN
    (8) stat -> . RETURN exp
    (9) stat -> . RETURN ;
    (10) stat -> . RETURN exp ;
    (24) empty -> .
    (11) varlist -> . var
    (12) varlist -> . var , varlist
    (13) var -> . IDENTIFIER

    ;               shift and go to state 6
    RETURN          shift and go to state 8
    $end            reduce using rule 24 (empty -> .)
    IDENTIFIER      shift and go to state 10

    chunk                          shift and go to state 1
    block                          shift and go to state 2
    stat_list                      shift and go to state 3
    stat                           shift and go to state 4
    empty                          shift and go to state 5
    varlist                        shift and go to state 7
    var                            shift and go to state 9

state 1

    (0) S' -> chunk .



state 2

    (1) chunk -> block .

    $end            reduce using rule 1 (chunk -> block .)


state 3

    (2) block -> stat_list .

    $end            reduce using rule 2 (block -> stat_list .)


state 4

    (3) stat_list -> stat . stat_list
    (3) stat_list -> . stat stat_list
    (4) stat_list -> . empty
    (5) stat -> . ;
    (6) stat -> . varlist = explist
    (7) stat -> . RETURN
    (8) stat -> . RETURN exp
    (9) stat -> . RETURN ;
    (10) stat -> . RETURN exp ;
    (24) empty -> .
    (11) varlist -> . var
    (12) varlist -> . var , varlist
    (13) var -> . IDENTIFIER

    ;               shift and go to state 6
    RETURN          shift and go to state 8
    $end            reduce using rule 24 (empty -> .)
    IDENTIFIER      shift and go to state 10

    stat                           shift and go to state 4
    stat_list                      shift and go to state 11
    empty                          shift and go to state 5
    varlist                        shift and go to state 7
    var                            shift and go to state 9

state 5

    (4) stat_list -> empty .

    $end            reduce using rule 4 (stat_list -> empty .)


state 6

    (5) stat -> ; .

    ;               reduce using rule 5 (stat -> ; .)
    RETURN          reduce using rule 5 (stat -> ; .)
    IDENTIFIER      reduce using rule 5 (stat -> ; .)
    $end            reduce using rule 5 (stat -> ; .)


state 7

    (6) stat -> varlist . = explist

    =               shift and go to state 12


state 8

    (7) stat -> RETURN .
    (8) stat -> RETURN . exp
    (9) stat -> RETURN . ;
    (10) stat -> RETURN . exp ;
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    RETURN          reduce using rule 7 (stat -> RETURN .)
    $end            reduce using rule 7 (stat -> RETURN .)
    ;               shift and go to state 14
    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

  ! ;               [ reduce using rule 7 (stat -> RETURN .) ]
  ! IDENTIFIER      [ reduce using rule 7 (stat -> RETURN .) ]

    exp                            shift and go to state 13
    var                            shift and go to state 17

state 9

    (11) varlist -> var .
    (12) varlist -> var . , varlist

    =               reduce using rule 11 (varlist -> var .)
    ,               shift and go to state 19


state 10

    (13) var -> IDENTIFIER .

    ,               reduce using rule 13 (var -> IDENTIFIER .)
    =               reduce using rule 13 (var -> IDENTIFIER .)
    ;               reduce using rule 13 (var -> IDENTIFIER .)
    PLUS            reduce using rule 13 (var -> IDENTIFIER .)
    MINUS           reduce using rule 13 (var -> IDENTIFIER .)
    TIMES           reduce using rule 13 (var -> IDENTIFIER .)
    DIVIDE          reduce using rule 13 (var -> IDENTIFIER .)
    RETURN          reduce using rule 13 (var -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 13 (var -> IDENTIFIER .)
    $end            reduce using rule 13 (var -> IDENTIFIER .)
    )               reduce using rule 13 (var -> IDENTIFIER .)


state 11

    (3) stat_list -> stat stat_list .

    $end            reduce using rule 3 (stat_list -> stat stat_list .)


state 12

    (6) stat -> varlist = . explist
    (14) explist -> . exp
    (15) explist -> . exp , explist
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    explist                        shift and go to state 20
    exp                            shift and go to state 21
    var                            shift and go to state 17

state 13

    (8) stat -> RETURN exp .
    (10) stat -> RETURN exp . ;
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

  ! shift/reduce conflict for ; resolved as shift
    RETURN          reduce using rule 8 (stat -> RETURN exp .)
    IDENTIFIER      reduce using rule 8 (stat -> RETURN exp .)
    $end            reduce using rule 8 (stat -> RETURN exp .)
    ;               shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 26

  ! ;               [ reduce using rule 8 (stat -> RETURN exp .) ]


state 14

    (9) stat -> RETURN ; .

    ;               reduce using rule 9 (stat -> RETURN ; .)
    RETURN          reduce using rule 9 (stat -> RETURN ; .)
    IDENTIFIER      reduce using rule 9 (stat -> RETURN ; .)
    $end            reduce using rule 9 (stat -> RETURN ; .)


state 15

    (23) exp -> MINUS . exp
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 27
    var                            shift and go to state 17

state 16

    (20) exp -> ( . exp )
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 28
    var                            shift and go to state 17

state 17

    (21) exp -> var .

    ;               reduce using rule 21 (exp -> var .)
    PLUS            reduce using rule 21 (exp -> var .)
    MINUS           reduce using rule 21 (exp -> var .)
    TIMES           reduce using rule 21 (exp -> var .)
    DIVIDE          reduce using rule 21 (exp -> var .)
    RETURN          reduce using rule 21 (exp -> var .)
    IDENTIFIER      reduce using rule 21 (exp -> var .)
    $end            reduce using rule 21 (exp -> var .)
    ,               reduce using rule 21 (exp -> var .)
    )               reduce using rule 21 (exp -> var .)


state 18

    (22) exp -> NUMBER .

    ;               reduce using rule 22 (exp -> NUMBER .)
    PLUS            reduce using rule 22 (exp -> NUMBER .)
    MINUS           reduce using rule 22 (exp -> NUMBER .)
    TIMES           reduce using rule 22 (exp -> NUMBER .)
    DIVIDE          reduce using rule 22 (exp -> NUMBER .)
    RETURN          reduce using rule 22 (exp -> NUMBER .)
    IDENTIFIER      reduce using rule 22 (exp -> NUMBER .)
    $end            reduce using rule 22 (exp -> NUMBER .)
    ,               reduce using rule 22 (exp -> NUMBER .)
    )               reduce using rule 22 (exp -> NUMBER .)


state 19

    (12) varlist -> var , . varlist
    (11) varlist -> . var
    (12) varlist -> . var , varlist
    (13) var -> . IDENTIFIER

    IDENTIFIER      shift and go to state 10

    var                            shift and go to state 9
    varlist                        shift and go to state 29

state 20

    (6) stat -> varlist = explist .

    ;               reduce using rule 6 (stat -> varlist = explist .)
    RETURN          reduce using rule 6 (stat -> varlist = explist .)
    IDENTIFIER      reduce using rule 6 (stat -> varlist = explist .)
    $end            reduce using rule 6 (stat -> varlist = explist .)


state 21

    (14) explist -> exp .
    (15) explist -> exp . , explist
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    ;               reduce using rule 14 (explist -> exp .)
    RETURN          reduce using rule 14 (explist -> exp .)
    IDENTIFIER      reduce using rule 14 (explist -> exp .)
    $end            reduce using rule 14 (explist -> exp .)
    ,               shift and go to state 30
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 26


state 22

    (10) stat -> RETURN exp ; .

    ;               reduce using rule 10 (stat -> RETURN exp ; .)
    RETURN          reduce using rule 10 (stat -> RETURN exp ; .)
    IDENTIFIER      reduce using rule 10 (stat -> RETURN exp ; .)
    $end            reduce using rule 10 (stat -> RETURN exp ; .)


state 23

    (16) exp -> exp PLUS . exp
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 31
    var                            shift and go to state 17

state 24

    (17) exp -> exp MINUS . exp
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 32
    var                            shift and go to state 17

state 25

    (18) exp -> exp TIMES . exp
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 33
    var                            shift and go to state 17

state 26

    (19) exp -> exp DIVIDE . exp
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 34
    var                            shift and go to state 17

state 27

    (23) exp -> MINUS exp .
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    ;               reduce using rule 23 (exp -> MINUS exp .)
    PLUS            reduce using rule 23 (exp -> MINUS exp .)
    MINUS           reduce using rule 23 (exp -> MINUS exp .)
    TIMES           reduce using rule 23 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 23 (exp -> MINUS exp .)
    RETURN          reduce using rule 23 (exp -> MINUS exp .)
    IDENTIFIER      reduce using rule 23 (exp -> MINUS exp .)
    $end            reduce using rule 23 (exp -> MINUS exp .)
    ,               reduce using rule 23 (exp -> MINUS exp .)
    )               reduce using rule 23 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! TIMES           [ shift and go to state 25 ]
  ! DIVIDE          [ shift and go to state 26 ]


state 28

    (20) exp -> ( exp . )
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    )               shift and go to state 35
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 26


state 29

    (12) varlist -> var , varlist .

    =               reduce using rule 12 (varlist -> var , varlist .)


state 30

    (15) explist -> exp , . explist
    (14) explist -> . exp
    (15) explist -> . exp , explist
    (16) exp -> . exp PLUS exp
    (17) exp -> . exp MINUS exp
    (18) exp -> . exp TIMES exp
    (19) exp -> . exp DIVIDE exp
    (20) exp -> . ( exp )
    (21) exp -> . var
    (22) exp -> . NUMBER
    (23) exp -> . MINUS exp
    (13) var -> . IDENTIFIER

    (               shift and go to state 16
    NUMBER          shift and go to state 18
    MINUS           shift and go to state 15
    IDENTIFIER      shift and go to state 10

    exp                            shift and go to state 21
    explist                        shift and go to state 36
    var                            shift and go to state 17

state 31

    (16) exp -> exp PLUS exp .
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    ;               reduce using rule 16 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 16 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 16 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 16 (exp -> exp PLUS exp .)
    IDENTIFIER      reduce using rule 16 (exp -> exp PLUS exp .)
    $end            reduce using rule 16 (exp -> exp PLUS exp .)
    ,               reduce using rule 16 (exp -> exp PLUS exp .)
    )               reduce using rule 16 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 26

  ! TIMES           [ reduce using rule 16 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 16 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]


state 32

    (17) exp -> exp MINUS exp .
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    ;               reduce using rule 17 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 17 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 17 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 17 (exp -> exp MINUS exp .)
    IDENTIFIER      reduce using rule 17 (exp -> exp MINUS exp .)
    $end            reduce using rule 17 (exp -> exp MINUS exp .)
    ,               reduce using rule 17 (exp -> exp MINUS exp .)
    )               reduce using rule 17 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 26

  ! TIMES           [ reduce using rule 17 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 17 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]


state 33

    (18) exp -> exp TIMES exp .
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    ;               reduce using rule 18 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 18 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 18 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 18 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 18 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 18 (exp -> exp TIMES exp .)
    IDENTIFIER      reduce using rule 18 (exp -> exp TIMES exp .)
    $end            reduce using rule 18 (exp -> exp TIMES exp .)
    ,               reduce using rule 18 (exp -> exp TIMES exp .)
    )               reduce using rule 18 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! TIMES           [ shift and go to state 25 ]
  ! DIVIDE          [ shift and go to state 26 ]


state 34

    (19) exp -> exp DIVIDE exp .
    (16) exp -> exp . PLUS exp
    (17) exp -> exp . MINUS exp
    (18) exp -> exp . TIMES exp
    (19) exp -> exp . DIVIDE exp

    ;               reduce using rule 19 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 19 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 19 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 19 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 19 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 19 (exp -> exp DIVIDE exp .)
    IDENTIFIER      reduce using rule 19 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 19 (exp -> exp DIVIDE exp .)
    ,               reduce using rule 19 (exp -> exp DIVIDE exp .)
    )               reduce using rule 19 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! TIMES           [ shift and go to state 25 ]
  ! DIVIDE          [ shift and go to state 26 ]


state 35

    (20) exp -> ( exp ) .

    ;               reduce using rule 20 (exp -> ( exp ) .)
    PLUS            reduce using rule 20 (exp -> ( exp ) .)
    MINUS           reduce using rule 20 (exp -> ( exp ) .)
    TIMES           reduce using rule 20 (exp -> ( exp ) .)
    DIVIDE          reduce using rule 20 (exp -> ( exp ) .)
    RETURN          reduce using rule 20 (exp -> ( exp ) .)
    IDENTIFIER      reduce using rule 20 (exp -> ( exp ) .)
    $end            reduce using rule 20 (exp -> ( exp ) .)
    ,               reduce using rule 20 (exp -> ( exp ) .)
    )               reduce using rule 20 (exp -> ( exp ) .)


state 36

    (15) explist -> exp , explist .

    ;               reduce using rule 15 (explist -> exp , explist .)
    RETURN          reduce using rule 15 (explist -> exp , explist .)
    IDENTIFIER      reduce using rule 15 (explist -> exp , explist .)
    $end            reduce using rule 15 (explist -> exp , explist .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ; in state 8 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 8 resolved as shift
WARNING: shift/reduce conflict for ; in state 13 resolved as shift
